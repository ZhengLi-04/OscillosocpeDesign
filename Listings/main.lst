C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          #include <absacc.h>
   3          #include <math.h>
   4          
   5          #define ADC_BASE_ADDR 0x0000
   6          #define DAC_CH2 0x2000
   7          #define DAC_CH1 0x4000
   8          #define ADC_INIT 0x83
   9          #define ADC_START 0x8B
  10          #define ADC_FLAG 0x10
  11          #define SIN_BASE_ADDR 0x1C00
  12          #define TRI_BASE_ADDR 0x1D00
  13          #define SQU_BASE_ADDR 0x1E00
  14          #define STW_BASE_ADDR 0x1F00
  15          
  16          sbit D_SER     = P1 ^ 0;
  17          sbit D_SRCLK   = P1 ^ 1;
  18          sbit D_RCLK    = P1 ^ 2;
  19          sbit KEY1      = P3 ^ 4;
  20          sbit KEY2      = P3 ^ 5;
  21          sbit EADC      = 0xAD;
  22          sbit PADC      = 0xBD;
  23          sfr CLK_DIV    = 0x97;
  24          sfr ADC_CONTR  = 0xBC;
  25          sfr ADC_RES    = 0xBD;
  26          sfr P1ASF      = 0x9D;
  27          
  28          unsigned char updateAmpFlag = 0;
  29          unsigned char updateFreFlag = 0;
  30          unsigned char mode1Status = 0;
  31          //mode1status = 0初始 1循环显示 2波形 3改幅度 4该频率
  32          unsigned int         ad_temp = 0;
  33          unsigned char        dspbuf[4] = {0xef, 0xef, 0xef, 0xef}, sel = 0;
  34          unsigned int         clocktime = 0, adcount = 0;
  35          unsigned char        ADC_RESULT = 0;
  36          unsigned char        DAC_VALUE = 0;
  37          unsigned char        OUTPUT_VALUE = 0;
  38          unsigned int         adAddr = ADC_BASE_ADDR;
  39          unsigned int         daAddr = ADC_BASE_ADDR;
  40          unsigned int         sinAddr = SIN_BASE_ADDR;
  41          unsigned int         triAddr = TRI_BASE_ADDR;
  42          unsigned int         squAddr = SQU_BASE_ADDR;
  43          unsigned int         stwAddr = STW_BASE_ADDR;
  44          unsigned char        key_sta = 0, key_num;
  45          unsigned char        workMode = 0;
  46          unsigned char        outputWaveMode = 1;
  47          unsigned char        outputWaveValue = 0;
  48          unsigned char        outputFreq = 10;
  49          float                 outputAmp = 1.0;
  50          unsigned int        inputFreq = 0;
  51          float               inputAmp = 0.0;
  52          unsigned char        value = 0;
  53          unsigned char        valueBuffer = 0;
  54          unsigned char        amp = 0;
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 2   

  55          unsigned char        amp_last = 0;
  56          unsigned char        amp_up = 128;
  57          unsigned char        amp_low = 128;
  58          int                  fre = 0;
  59          int                  fre_up = 0;
  60          int                  fre_low = 0;
  61          float                fre_count = 0;
  62          unsigned char initStatus = 1; //1代表为初始化状态，不更新数码管内容。
  63          
  64          // 初始化
  65          void init_all();
  66          void init_timer0();
  67          void init_interrupts();
  68          void init_adc();
  69          void adc_start();
  70          // 按键函数
  71          void keyService();
  72          void keyWork();
  73          // 显示函数
  74          void dspTask();
  75          void dspNum(unsigned char n, unsigned char m);
  76          // 模式1信号发生函数
  77          void init_outputWave();
  78          void updateOutputWave();
  79          // 模式3波形测量函数
  80          void ampMeasure();
  81          void freMeasure();
  82          // 主函数、其他函数
  83          void delay(int delayTime);
  84          void main(void);
  85          
  86          /*-----------初始化函数-----------*/
  87          void init_timer0()
  88          {
  89   1          TMOD &= 0XF0;
  90   1          TMOD |= 0X02;
  91   1          TL0 = 0X06;
  92   1          TH0 = 0X06;
  93   1          TR0 = 1;
  94   1      }
  95          
  96          void init_timer1()
  97          {
  98   1          TMOD &= 0x0F;
  99   1          TMOD |= 0x20;
 100   1          TL1 = 0x06;
 101   1          TH1 = 0x06;
 102   1          TR1 = 1;
 103   1      }
 104          
 105          void init_interrupts()
 106          {
 107   1          EA  = 1;
 108   1          ET0 = 1;
 109   1          ET1 = 1;
 110   1          EADC = 1;
 111   1          PT0 = 1;
 112   1          PT1 = 0;
 113   1          PADC = 0;
 114   1      }
 115          
 116          void init_adc()
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 3   

 117          {
 118   1          P1ASF = 0x08;
 119   1          ADC_CONTR = ADC_INIT;
 120   1          delay(2);
 121   1      }
 122          
 123          void init_all()
 124          {
 125   1          CLK_DIV = CLK_DIV | 0x01;
 126   1          init_timer0();
 127   1          init_timer1();
 128   1          init_interrupts();
 129   1          init_adc();
 130   1          init_outputWave();
 131   1      }
 132          
 133          
 134          /*----------中断相关函数-----------*/
 135          void timer_isr() interrupt 1
 136          {
 137   1          EA = 0;
 138   1          adcount++;
 139   1          adc_start();
 140   1          if (adcount == 3)
 141   1          {
 142   2              updateOutputWave();
 143   2          }
 144   1          if (adcount == 5)
 145   1          {
 146   2              dspTask();
 147   2              keyService();
 148   2              adcount = 0;
 149   2          }
 150   1          EA = 1;
 151   1      }
 152          
 153          void updateFeature() interrupt 3
 154          {
 155   1          EA = 0;
 156   1          clocktime++;
 157   1          if (workMode == 3)
 158   1          {
 159   2              ampMeasure();
 160   2              freMeasure();
 161   2          }
 162   1          if (workMode == 1)
 163   1          {
 164   2              daAddr = adAddr;
 165   2              if (adAddr > 0x1Bf0)
 166   2              {
 167   3                  adAddr = ADC_BASE_ADDR;
 168   3              }
 169   2              XBYTE[adAddr] = (ADC_RESULT - 64) * 2;
 170   2              ad_temp = ADC_RESULT;
 171   2              adAddr++;
 172   2          }
 173   1          if (workMode == 2)
 174   1          {
 175   2              if (daAddr > 0x1Bf0)
 176   2              {
 177   3                  daAddr = ADC_BASE_ADDR;
 178   3              }
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 4   

 179   2              OUTPUT_VALUE = XBYTE[daAddr] / 2;
 180   2              daAddr++;
 181   2          }
 182   1          if (workMode == 3)
 183   1          {
 184   2              daAddr = adAddr;
 185   2              if (adAddr > 0x0800)
 186   2              {
 187   3                  adAddr = ADC_BASE_ADDR;
 188   3              }
 189   2              XBYTE[adAddr] = (ADC_RESULT - 64) * 2;
 190   2              ad_temp = ADC_RESULT;
 191   2              adAddr++;
 192   2          }
 193   1          if (clocktime == 4000)
 194   1          {
 195   2              clocktime = 0;
 196   2          }
 197   1          EA = 1;
 198   1      }
 199          
 200          void adc_work() interrupt 5
 201          {
 202   1          ADC_CONTR = ADC_INIT;
 203   1          ADC_RESULT = ADC_RES / 2 + 64;
 204   1      }
 205          
 206          void adc_start()
 207          {
 208   1          ADC_CONTR = ADC_START;
 209   1          switch (workMode)
 210   1          {
 211   2          case 1:
 212   2          {
 213   3              XBYTE[DAC_CH1] = DAC_VALUE;
 214   3              XBYTE[DAC_CH2] = outputWaveValue;
 215   3          }
 216   2          break;
 217   2          case 2:
 218   2          {
 219   3              XBYTE[DAC_CH1] = DAC_VALUE;
 220   3              XBYTE[DAC_CH2] = OUTPUT_VALUE;
 221   3          }
 222   2          break;
 223   2          case 3:
 224   2          {
 225   3              XBYTE[DAC_CH1] = DAC_VALUE;
 226   3              XBYTE[DAC_CH2] = 0x00;
 227   3          }
 228   2          break;
 229   2          default:
 230   2              break;
 231   2          }
 232   1      }
 233          
 234          
 235          /*----------按键相关函数-----------*/
 236          // 按键扫描
 237          void keyService()
 238          {
 239   1          if (key_sta & 0x01) return;
 240   1          if (KEY2)
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 5   

 241   1          {
 242   2              key_num = key_num + 1;
 243   2              key_sta = key_sta | 0x01;
 244   2          }
 245   1          else if (KEY1)
 246   1          {
 247   2              key_num = key_num + 5;
 248   2              key_sta = key_sta | 0x01;
 249   2          }
 250   1      }
 251          // 根据不同按下的键执行不同动作
 252          void keyWork()
 253          {
 254   1          unsigned int i, j;
 255   1          switch (key_num)
 256   1          {
 257   2          case 1:
 258   2          case 2:
 259   2          case 3:
 260   2              workMode = key_num;
 261   2              initStatus = 1;
 262   2              for (i = 0; i < 1000; i++)
 263   2              {
 264   3                  for (j = 0; j < 15; j++)
 265   3                  {
 266   4                      dspNum(22, 0);
 267   4                      dspNum(workMode, 1);
 268   4                      dspNum(22, 2);
 269   4                      dspNum(22, 3);
 270   4                  }
 271   3              }
 272   2              if (workMode == 1) mode1Status = 1;
 273   2              initStatus = 0;
 274   2              break;
 275   2          case 4:
 276   2              if (workMode == 1)
 277   2              {
 278   3                  if (mode1Status == 4)
 279   3                  {
 280   4                      mode1Status = 1;
 281   4                  }
 282   3                  else
 283   3                  {
 284   4                      mode1Status = mode1Status + 1;
 285   4                  }
 286   3              }
 287   2              delay(100);
 288   2              break;
 289   2          case 5:
 290   2              if (workMode == 1)
 291   2              {
 292   3                  if (mode1Status == 2)
 293   3                      outputWaveMode = 1;
 294   3                  else if (mode1Status == 3 && outputAmp <= 4)
 295   3                      outputAmp = outputAmp + 1;
 296   3                  else if (mode1Status == 4 && outputFreq <= 990)
 297   3                      outputFreq = outputFreq + 10;
 298   3              }
 299   2              delay(100);
 300   2              break;
 301   2          case 6:
 302   2              if (workMode == 1)
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 6   

 303   2              {
 304   3                  if (mode1Status == 2)
 305   3                      outputWaveMode = 2;
 306   3                  else if (mode1Status == 3 && outputAmp >= 2)
 307   3                      outputAmp = outputAmp - 1;
 308   3                  else if (mode1Status == 4 && outputFreq >= 20)
 309   3                      outputFreq = outputFreq - 10;
 310   3              }
 311   2              delay(100);
 312   2              break;
 313   2          case 7:
 314   2              if (workMode == 1)
 315   2              {
 316   3                  if (mode1Status == 2)
 317   3                      outputWaveMode = 3;
 318   3                  else if (mode1Status == 3 && outputAmp <= 4.9)
 319   3                      outputAmp = outputAmp + 0.1;
 320   3                  else if (mode1Status == 4 && outputFreq <= 999.8)
 321   3                      outputFreq = outputFreq + 1;
 322   3              }
 323   2              delay(100);
 324   2              break;
 325   2          case 8:
 326   2              if (workMode == 1)
 327   2              {
 328   3                  if (mode1Status == 2)
 329   3                      outputWaveMode = 4;
 330   3                  else if (mode1Status == 3 && outputAmp >= 0.2)
 331   3                      outputAmp = outputAmp - 0.1;
 332   3                  else if (mode1Status == 4 && outputFreq >= 2)
 333   3                      outputFreq = outputFreq - 1;
 334   3              }
 335   2              delay(100);
 336   2              break;
 337   2          default:
 338   2              break;
 339   2          }
 340   1      }
 341          
 342          /*----------显示相关函数-----------*/
 343          code unsigned char segCode[] =
 344          {
 345              /* 0-9 */  0x11, 0x7d, 0x23, 0x29, 0x4d, 0x89, 0x81, 0x3d, 0x01, 0x09,
 346              /* 0-9. */ 0x10, 0x7c, 0x22, 0x28, 0x4c, 0x88, 0x80, 0x3c, 0x00, 0x08,
 347              /* U */    0x51,
 348              /* F */    0x87,
 349              /* - */    0xef,
 350              /* ntrq */ 0x15, 0xc3, 0xe7, 0x0d
 351          };
 352          
 353          //根据段码表显示不同值
 354          void dspNum(unsigned char n, unsigned char m)
 355          {
 356   1          dspbuf[m] = (n < sizeof(segCode)) ? segCode[n] : 0x11;
 357   1      }
 358          
 359          // 数码管及led更新
 360          void dspTask()
 361          {
 362   1          unsigned char i;
 363   1          unsigned char a, b;
 364   1          switch (sel)
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 7   

 365   1          {
 366   2          case 0:
 367   2              a = 0x01;
 368   2              break;
 369   2          case 1:
 370   2              a = 0x02;
 371   2              break;
 372   2          case 2:
 373   2              a = 0x04;
 374   2              break;
 375   2          case 3:
 376   2              a = 0x08;
 377   2              break;
 378   2          default:
 379   2              a = 0x10;
 380   2              break;
 381   2          }
 382   1          for (b = 0x80, i = 0; i < 8; i++)
 383   1          {
 384   2              if (a & b)  D_SER = 1;
 385   2              else     D_SER = 0;
 386   2              D_SRCLK = 0;
 387   2              D_SRCLK = 1;
 388   2              D_SRCLK = 0;
 389   2              b = b >> 1;
 390   2              b = b & 0x7f;
 391   2          }
 392   1          if (sel <= 3)
 393   1          {
 394   2              a = dspbuf[sel];
 395   2          }
 396   1          else
 397   1          {
 398   2              switch (workMode)
 399   2              {
 400   3              case 1:
 401   3                  a = 0xF7;
 402   3                  break;
 403   3              case 2:
 404   3                  a = 0xFB;
 405   3                  break;
 406   3              case 3:
 407   3                  a = 0xFD;
 408   3                  break;
 409   3              default:
 410   3                  a = 0xFE;
 411   3                  break;
 412   3              }
 413   2          }
 414   1          if (sel <= 3)
 415   1              key_num = sel;
 416   1          sel++;
 417   1          if (sel > 4) sel = 0;
 418   1          for (b = 0x80, i = 0; i < 8; i++)
 419   1          {
 420   2              if (a & b)  D_SER = 1;
 421   2              else     D_SER = 0;
 422   2              D_SRCLK = 0;
 423   2              D_SRCLK = 1;
 424   2              D_SRCLK = 0;
 425   2              b = b >> 1;
 426   2              b = b & 0x7fff;
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 8   

 427   2          }
 428   1          D_RCLK = 0;
 429   1          D_RCLK = 1;
 430   1          D_RCLK = 0;
 431   1      }
 432          
 433          /*----------模式1函数-----------*/
 434          // 初始化标准波形
 435          void init_outputWave()
 436          {
 437   1          unsigned int addr = 0;
 438   1          unsigned int i = 0;
 439   1          //Sin Wave
 440   1          i = 0;
 441   1          addr = SIN_BASE_ADDR;
 442   1          for (; addr <= 0x1CFF; addr++, i++)
 443   1          {
 444   2              XBYTE[addr] = floor(14 * (sin(3.14 * i / 128) +1)) + 32; //14是根据硬件调整的经验值
 445   2          }
 446   1          //Triangular Wave
 447   1          i = 0;
 448   1          addr = TRI_BASE_ADDR;
 449   1          for (; addr <= 0x1D7F; addr++, i++)
 450   1          {
 451   2              XBYTE[addr] = 49 + floor(30 * (i / 128.0));
 452   2          }
 453   1          i = 0;
 454   1          addr = 0x1D80;
 455   1          for (; addr <= 0x1DFF; addr++, i++)
 456   1          {
 457   2              XBYTE[addr] = 79 - floor(30 * (i / 128.0));
 458   2          }
 459   1          //Square Wave
 460   1          addr = SQU_BASE_ADDR;
 461   1          for (; addr <= 0x1E7F; addr++)
 462   1          {
 463   2              XBYTE[addr] = 64 + 15;
 464   2          }
 465   1          addr = 0x1E80;
 466   1          for (; addr <= 0x1EFF; addr++)
 467   1          {
 468   2              XBYTE[addr] = 64 - 15;
 469   2          }
 470   1          //Sawtooth Wave
 471   1          i = 0;
 472   1          addr = STW_BASE_ADDR;
 473   1          for (; addr <= 0x1FFF; addr++, i++)
 474   1          {
 475   2              XBYTE[addr] = 64 - 15 + floor(30 * i / 256);
 476   2          }
 477   1      }
 478          
 479          // 根据设定值更新波形
 480          void updateOutputWave()
 481          {
 482   1          if (workMode == 1)
 483   1          {
 484   2              switch (outputWaveMode)
 485   2              {
 486   3              case 1:
 487   3              {
 488   4                  if (sinAddr <= 0x1CFF)
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 9   

 489   4                  {
 490   5                      if (outputAmp != 1)
 491   5                      {
 492   6                          outputWaveValue = (XBYTE[sinAddr] - 32) * outputAmp + 32;
 493   6                      }
 494   5                      else
 495   5                      {
 496   6                          outputWaveValue = XBYTE[sinAddr];
 497   6                      }
 498   5                      sinAddr = sinAddr + 1 + outputFreq / 1.6;
 499   5                  }
 500   4                  else
 501   4                  {
 502   5                      sinAddr = SIN_BASE_ADDR;
 503   5                      outputWaveValue = (XBYTE[sinAddr] - 32) * outputAmp + 32;
 504   5                      sinAddr = sinAddr + 1 + outputFreq / 1.6;
 505   5                  }
 506   4              }
 507   3              break;
 508   3              case 2:
 509   3              {
 510   4                  if (triAddr <= 0x1DF3)
 511   4                  {
 512   5                      outputWaveValue = (XBYTE[triAddr] - 64) * outputAmp + 64;
 513   5                      triAddr = triAddr + 1 + outputFreq / 1.6;
 514   5                  }
 515   4                  else
 516   4                  {
 517   5                      triAddr = TRI_BASE_ADDR;
 518   5                      outputWaveValue = (XBYTE[triAddr] - 64) * outputAmp + 64;
 519   5                      triAddr = triAddr + 1 + outputFreq / 1.6;
 520   5                  }
 521   4              }
 522   3              break;
 523   3              case 3:
 524   3              {
 525   4                  if (squAddr <= 0x1EFF)
 526   4                  {
 527   5                      outputWaveValue = (XBYTE[squAddr] - 64) * outputAmp + 64;
 528   5                      squAddr = squAddr + 1 + outputFreq / 1.6;
 529   5                  }
 530   4                  else
 531   4                  {
 532   5                      squAddr = SQU_BASE_ADDR;
 533   5                      outputWaveValue = (XBYTE[squAddr] - 64) * outputAmp + 64;
 534   5                      squAddr = squAddr + 1 + outputFreq / 1.6;
 535   5                  }
 536   4              }
 537   3              break;
 538   3              case 4:
 539   3              {
 540   4                  if (stwAddr <= 0x1FFF)
 541   4                  {
 542   5                      outputWaveValue = (XBYTE[stwAddr] - 64) * outputAmp + 64;
 543   5                      stwAddr = stwAddr + 1 + outputFreq / 1.6 ;
 544   5                  }
 545   4                  else
 546   4                  {
 547   5                      stwAddr = STW_BASE_ADDR;
 548   5                      outputWaveValue = (XBYTE[stwAddr] - 64) * outputAmp + 64;
 549   5                      stwAddr = stwAddr + 1 + outputFreq / 1.6 ;
 550   5                  }
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 10  

 551   4              }
 552   3              break;
 553   3              default:
 554   3                  break;
 555   3              }
 556   2          }
 557   1      }
 558          /*----------模式3函数-----------*/
 559          // 幅值测量函数
 560          void ampMeasure()
 561          {
 562   1          amp = ADC_RESULT;
 563   1          if (amp > amp_up)
 564   1          {
 565   2              amp_up = amp;
 566   2          }
 567   1          if (amp < amp_low)
 568   1          {
 569   2              amp_low = amp;
 570   2          }
 571   1          if (adAddr > 0x0800)
 572   1          {
 573   2              inputAmp = (amp_up * 5.0 / 1.1 - amp_low * 5.0 / 1.1) / 128;
 574   2              amp_up = amp_low = 128;
 575   2          }
 576   1      }
 577          //频率测量函数
 578          void freMeasure()
 579          {
 580   1          amp = ADC_RESULT;
 581   1          if (amp > 128 && amp_last <= 128)
 582   1          {
 583   2              fre_up = adAddr;
 584   2              if (fre_low != 0)
 585   2              {
 586   3                  fre = fre + fabs(fre_low - fre_up);
 587   3                  fre_count++;
 588   3              }
 589   2              fre_low = fre_up;
 590   2          }
 591   1          if (adAddr > 0x0800)
 592   1          {
 593   2              inputFreq = floor(2000 / (fre * 1.0 / fre_count));
 594   2              fre = 0;
 595   2              fre_up = fre_low = 0;
 596   2              fre_count = 0;
 597   2              amp = amp_last = 129;
 598   2          }
 599   1          amp_last = amp;
 600   1      }
 601          
 602          /*----------其他函数-----------*/
 603          // 延时模块
 604          void delay(int delayTime)
 605          {
 606   1          unsigned int x;
 607   1          while (delayTime--)
 608   1          {
 609   2              x = 1000;
 610   2              while (x--);
 611   2          }
 612   1      }
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 11  

 613          
 614          /*----------主函数-----------*/
 615          void main(void)
 616          {
 617   1          init_all();
 618   1          for (;;)
 619   1          {
 620   2              switch (workMode)
 621   2              {
 622   3              case 0:
 623   3              {
 624   4                  initStatus = 1;
 625   4                  dspNum(22, 0);
 626   4                  dspNum(22, 1);
 627   4                  dspNum(22, 2);
 628   4                  dspNum(22, 3);
 629   4              }
 630   3              break;
 631   3              case 1:
 632   3              {
 633   4                  DAC_VALUE = ADC_RESULT;
 634   4                  if (initStatus == 0)
 635   4                  {
 636   5                      if (mode1Status == 1)
 637   5                      {
 638   6                          if (clocktime < 2000)
 639   6                          {
 640   7                              dspNum(21, 0);
 641   7                              if (outputFreq > 999) outputFreq = 999;
 642   7                              if (outputFreq <= 0) outputFreq = 0;
 643   7                              dspNum((outputFreq / 100) % 10, 1);
 644   7                              dspNum((outputFreq / 10) % 10, 2);
 645   7                              dspNum(outputFreq % 10, 3);
 646   7                          }
 647   6                          else
 648   6                          {
 649   7                              valueBuffer = (int)(outputAmp * 10);
 650   7      
 651   7                              dspNum(20, 0);
 652   7                              dspNum((valueBuffer / 100) % 10, 1);
 653   7                              dspNum((valueBuffer / 10) % 10 + 10, 2);
 654   7                              dspNum((valueBuffer / 1) % 10, 3);
 655   7                          }
 656   6                      }
 657   5                      else if (mode1Status == 2)
 658   5                      {
 659   6                          if (outputWaveMode == 1)
 660   6                          {
 661   7                              dspNum(22, 0);
 662   7                              dspNum(5, 1);
 663   7                              dspNum(1, 2);
 664   7                              dspNum(23, 3);
 665   7                          }
 666   6                          else if (outputWaveMode == 2)
 667   6                          {
 668   7                              dspNum(22, 0);
 669   7                              dspNum(24, 1);
 670   7                              dspNum(25, 2);
 671   7                              dspNum(1, 3);
 672   7                          }
 673   6                          else if (outputWaveMode == 3)
 674   6                          {
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 12  

 675   7                              dspNum(22, 0);
 676   7                              dspNum(5, 1);
 677   7                              dspNum(26, 2);
 678   7                              dspNum(20, 3);
 679   7                          }
 680   6                          else if (outputWaveMode == 4)
 681   6                          {
 682   7                              dspNum(22, 0);
 683   7                              dspNum(5, 1);
 684   7                              dspNum(24, 2);
 685   7                              dspNum(22, 3);
 686   7                          }
 687   6                      }
 688   5                      else if (mode1Status == 3)
 689   5                      {
 690   6                          valueBuffer = (int)(outputAmp * 10);
 691   6      
 692   6                          dspNum(20, 0);
 693   6                          dspNum((valueBuffer / 100) % 10, 1);
 694   6                          dspNum((valueBuffer / 10) % 10 + 10, 2);
 695   6                          dspNum((valueBuffer / 1) % 10, 3);
 696   6      
 697   6                      }
 698   5                      else if (mode1Status == 4)
 699   5                      {
 700   6                          dspNum(21, 0);
 701   6                          if (outputFreq > 999) outputFreq = 999;
 702   6                          if (outputFreq <= 0) outputFreq = 0;
 703   6                          dspNum((outputFreq / 100) % 10, 1);
 704   6                          dspNum((outputFreq / 10) % 10, 2);
 705   6                          dspNum(outputFreq % 10, 3);
 706   6                      }
 707   5                  }
 708   4              }
 709   3              break;
 710   3              case 2:
 711   3              {
 712   4                  DAC_VALUE = ADC_RESULT;
 713   4              }
 714   3              break;
 715   3              case 3:
 716   3              {
 717   4                  DAC_VALUE = ADC_RESULT;
 718   4                  if (initStatus == 0)
 719   4                  {
 720   5                      if (clocktime < 2000)
 721   5                      {
 722   6                          updateAmpFlag = 1;
 723   6                          if (updateFreFlag == 1)
 724   6                          {
 725   7                              updateFreFlag = 0;
 726   7                              dspNum(21, 0);
 727   7                              if (inputFreq > 999)inputFreq = 999;
 728   7                              if (inputFreq <= 0)inputFreq = 0;
 729   7                              dspNum((inputFreq / 100) % 10, 1);
 730   7                              dspNum((inputFreq / 10) % 10, 2);
 731   7                              dspNum(inputFreq % 10, 3);
 732   7                          }
 733   6      
 734   6                      }
 735   5                      else
 736   5                      {
C51 COMPILER V9.54   MAIN                                                                  04/06/2025 20:38:42 PAGE 13  

 737   6                          updateFreFlag = 1;
 738   6                          if (updateAmpFlag == 1)
 739   6                          {
 740   7                              updateAmpFlag = 0;
 741   7                              value = (int)(inputAmp * 10);
 742   7                              dspNum(20, 0);
 743   7                              dspNum((value / 100) % 10, 1);
 744   7                              dspNum((value / 10) % 10 + 10, 2);
 745   7                              dspNum((value / 1) % 10, 3);
 746   7                          }
 747   6      
 748   6                      }
 749   5                  }
 750   4              }
 751   3              break;
 752   3              default:
 753   3                  break;
 754   3              }
 755   2              if (key_sta & 0x01)
 756   2              {
 757   3                  keyWork();
 758   3                  key_sta = key_sta & 0xfe;
 759   3              }
 760   2      
 761   2          }
 762   1      }
 763          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3295    ----
   CONSTANT SIZE    =     27    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     62       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
